---
title: 1.数据类型
date: 2025-11-26T19:44:40Z
lastmod: 2025-11-26T19:45:01Z
---

# 1.数据类型

# 1.引入

> 程序离不开数据，我们将一些数据输入到计算机，然后让其利用这些数据完成某些任务

```
    计算机在计算之前首先要解决数据的保存问题，在保存数据之前，我们首先要了解数据大小、类型，
    如果不知道这些"数据类型"，则无法确定开辟多大的空间去保存他们

    比如: 整数，小数，字符...
    C语言让程序员针对不同的情况选择不同的数据类型

```

# 2.C语言中的数据类型

## 2.1 基本类型

> C中已经定义好，直接可以使用的

```c
    整型数据: int (整型)、 short (短整型)、 long (长整型) 、 long long 
    浮点型数据: float (单精度浮点)、 double (双精度浮点)
    字符型数据: char 

    char/unsigned char : 1 byte (字节) == 8 bits

    不同的编译器 short 、int、 long 所占的字节数不一样
    如 gcc 环境下下:
    sizeof(int) ---> 求这个类型占用的内存大小
    *sizeof 是一个运算符，用于计算数据类型或者变量的大小(字节为单位)
        sizeof(short) = 2
        sizeof(int) = 4
        sizeof(long) = 8
    以int为例:
    sizeof(int) = 4 表示int类型占4个字节，32 bits
    0000 0000 0000 0000 0000 0000 0000 0000   表示数值 0
    float 单精度浮点，一般占4bytes
    double 高精度浮点，一般占8bytes
    long double 长双精度浮点       >= 10 bytes 

    //C语言中，整数默认类型是 int ， 小数默认的类型是 double

    typeof(1) = int 
    //typeof ---> 获取表达式的类型

    typeof(1.0) = double 

    //C规定short 占用的存储空间不能多于int，long占用的存储空间不能少于int


```

|各类型字节数|32位机|64位机|
| -----------------| ------| ------|
|char|1|1|
|short|2|2|
|int|4|4|
|long|4|8|
|float|4|4|
|double|8|8|
|char*（指针类型）|4|8|

## 2.2构造类型: 自定义的类型

```c
    //C语言中允许程序员自定义类型
    数组
    结构体
    联合体
    枚举
    //之后会讲
```

## 2.3指针类型

```

    int* p;

```

## 2.4 void

```c
    空类型，C语言中，void 总共可以在三个地方出现:
    1. void 当函数的参数,表示该函数无参数
    int func(void)
    {

    }

    2. void 当函数的返回值类型，表示该函数无返回值
    void func(int a)
    {

    }

    3. void* 表示通用指针


```

# 3.变量

```c
数据对象分为两类:
    *变量: 在程序运行期间，其值可以被修改的数据对象

    变量的本质就是内存中一个具有特定属性的存储单元，他是用来存储数据的
    这个存储单元中的数值，就是变量的值，而这个值在程序运行期间可能被改变


    *常量: 在程序运行期间，其值不能被修改的数据对象

1.变量的定义
    变量: "先定义，后使用"
    原因: 让编译器知道变量的类型和存储空间大小，为其分配适当的内存.
    定义语法:
        变量的类型 变量名 { = 初始值} ; {}可选

        int a = 10; //申请一个空间，命名为a,并且将空间的内容初始化为10

        变量的类型:
            任意合法的C语言类型都可以
            基本类型/构造类型/指针类型/void*
    *变量名规范:
    1.不能和关键字冲突，区分大小写
        int INT; //OK
        int int; //错误

    2.变量名不能以数字开头，并且名称只能包含 数字、字母、下划线
        int Byte_8; //OK
        int 8_Byte; //错误

    3.编程规范，见名知意 --- 提高代码可读性
        int age = 18; //年龄
        double height = 176.9; //身高

    4.选取合适的数据类型




    例:
        int x;
        printf("x = %d \n",x); 

        此处x的值是一个不确定的值，没有赋初始值，不代表它没有值。

        \n 换行符 是一个 转义序列(escape squeue)
        转义序列用来代表难以表示或者无法输入的内容。 
        \t  代表tab键
        \b  代表Backspace(退格键)
        每个转义序列都以反斜杠字符(\) 开始 


2.变量的属性
    int a = 5; 

    变量名

    变量的存储单元:
        程序运行期间，会为每一个变量分配一个大小合适的存储单元
        存储单元按字节大小编号。这个编号称之为存储单元的地址。
        变量的存储单元会有一个唯一的编号，变量的地址

    变量的值:
        变量的存储单元中的内容
        1 Byte = 8 bits
        1 bit latch 保存的就是一个"电压值"
            高电平  1
            低电平  0


3.变量的访问
    read/write


    a = 5; //把数值5 存储到变量a的地址中去
    b = a; //把变量a的值，赋值给变量b


    C语言中，任何一个变量都有两个意思
    (1)左值: 代表变量的地址
        lvalue: location value 可写的地址

    (2)右值: 代表变量的值
        rvalue: readable value 可读的值

```

# 4.整型变量存储

```c
1. 整型在存储器中是如何存放的

    /*1.首先了解什么是原码: */
    最高位作符号位 0 表示正数 1表示负数，其余的位表示数值的绝对值
    以char为例， 1字节 8 bits
    char: -128~127
        0(正) 111 1111  --> +127
        1(负) 111 1111  --> -127
        1000 0000       --> -0 看作 1 1000 0000  --> -128

    unsigned char : 0-255

    int a = 5;
            转换为二进制---> 0101

    /*2.整数在计算机中是以二进制补码的形式存放的*/
    补码:
        1.正数的补码就是其原码本身
            13: 8 bits下
            0000 1101 //13在计算机中的存放形式(8bits)


       **2.负数的补码其 绝对值的原码取反后+1 的到**
            -13: 8 bits下
            0000 1101 //13的原码
            1111 0010 //取反
            1111 0011 //+1h后。 -13在计算机中的存放形式(8bits)

//为什么需要补码?
例如 8 bits 下: 
1+1时:
    0000 0001
   +0000 0001
    ----------
    0000 0010 --> 2 

1-1时及 1+(-1):
    0000 0001
   +1000 0001
    ---------
    1000 0010 ---> -2 
    这种计算结果显然是不对的
    所以为了方便计算，使用补码存储更合理

```

## 练习

```
假设都是8 bits存储一个整数
    1.  -3的补码是? 

    绝对值: 3
    原码:       0000 0011
    取反:       1111 1100
    补码(+1):   1111 1101

    2. 253 在计算机中的存储形式是？
    256-3 == 253
    1 0000 0000 (2^8 即 256)
    -3得到
        1111 1101  --> 253


    3. -1在计算机中的存储形式是？
        255在计算机中的存储形式是？

    -1绝对值 : 1
    原码:       0000 0001
    取反:       1111 1110
    补码(+1):   1111 1111
    
    255 == 256-1
    1 0000 0000 (256)
    -1得到
    1111 1111   (255)


```

## 结论

```
    1.一个负数 会和 某一个比较大的正数的补码形式一样

    计算公式:
        -x  与  2^n - x  补码形式一样


    2.CPU底层没有符号位的概念，都是数值位，都参与运算

    至于这个数到底是正数还是负数，取决于编译器的词义
    换而言之，取决于您把这个数当作有符号还是无符号数

    编译器(逻辑层面)
        有符号数
            符号位(最高位) + 数值位(其他位)
            1 负数
            0 正数
        
        无符号数
            数值位(全部)

```

## 练习

```c

1. 假设int 是32bits
    int a = -3;
    a.变量a的存储单元中的内容是?

    绝对值: 3 
    原码:
    0000 0000 0000 0000 0000 0000 0000 0011
    取反:
    1111 1111 1111 1111 1111 1111 1111 1100
    +1:
    1111 1111 1111 1111 1111 1111 1111 1101  //-3 在计算机中的存储形式


    b.如果执行如下程序，打印的结果是?
        printf("%d \n",a); 
        输出 -3 
        printf("%u \n",a); //u表示无符号 unsigned
        输出 2^32-3

        %d : 把a当作一个有符号数 signed int 输出(十进制形式)
        %u : 把a当作一个无符号数 unsigned int 输出(全部都是数值位)(十进制形式)
        
        逆运算: 
        -1
            1111 1111 1111 1111 1111 1111 1111 1100
        取反
            0000 0000 0000 0000 0000 0000 0000 0011  <---它绝对值的原码




2. 分析如下程序的输出结果
        unsigned int a = -4u; //此处u表示无符号
        printf("%d \n",a); 
        printf("%u \n",a);

        -4/-4u
        绝对值原码:
        0000 0000 0000 0000 0000 0000 0000 0100
        取反:
        1111 1111 1111 1111 1111 1111 1111 1011
        +1:
        1111 1111 1111 1111 1111 1111 1111 1100 
        //-4在计算机中存放形式，变量a存储单元中的内容如上


        %d: 把这个数当作一个有符号数
        1111 1111 1111 1111 1111 1111 1111 1100
        最高位是1，它是一个负数的补码，这个负数是多少，逆运算求出即可
        -1:
        1111 1111 1111 1111 1111 1111 1111 1011
        取反:
        0000 0000 0000 0000 0000 0000 0000 0100
        //它的绝对值原码如上所属， 4
        // -4 
        %u: 把这个数当作一个无符号数
        1111 1111 1111 1111 1111 1111 1111 1100
        ---> 2^32 -1 -3

-----------------
总结:
    1.理解变量的属性以及变量的左值、右值

    2.整数在计算机中的存放形式:
        2.1 一个负数会和一个比较大的整数的补码形式相同
            -x 和 2^n -x
        2.2 CPU底层没有符号位的概念， 都是数值位，都参与运算
            具体是整数还是负数，取决于把它当作有符号还是无符号

```

# *5. 不同类型的整型之间的赋值

```c
    C允许不同的整数之间互相赋值
    char a; 8 bits
    int  b; 32 bits
    short c; 16 bits

    a = b ;
    a = c ;

    需要注意不同长度的赋值，以及赋值后的处理.

**标准C建议如下:**
    1.长-->短
        低字节直接拷贝，高字节直接丢弃(discard)

    2.短-->长
        低字节直接拷贝，高位需要补
        如果短的是有符号数，高位就补符号位
        如果短的是无符号数，高位就全补0


--------
例如: 假设运行如下代码的机器是32bits，请分析输出结果 (注意转换)
    unsigned char c = 250;
    char d;

    d = c + 8;

    printf("%d \n",d); //2
    printf("%u \n",d); //2

    c: 8 bits --> 1111 1010
    c+8: //注意： 此处c会变成32bits
    //隐式转换，转换成相同的类型，所以c会变到32bits
    c-->32 bits ,短变长，c为 unsigned char 无符号数，所以高位补0:
                                  1111 1010
    0000 0000 0000 0000 0000 0000 1111 1010  c
+
    0000 0000 0000 0000 0000 0000 0000 1000  8
    0000 0000 0000 0000 0000 0001 0000 0010  c+8
    
    将c+8的结果赋值给 d (char 类型) ,长变短，低字节直接拷贝，高字节字节丢弃
    d:
        0000 0010

    %d: 将d当作int类型
    d-> int: 短-->长，低字节直接拷贝，高字节补符号位 (0)

                                  0000 0010
    0000 0000 0000 0000 0000 0000 0000 0010  ---> 2


```

## 练习

```c
    1.分析如下程序的输出结果，机器是32bits

    char c = 250;
    printf("%d \n", c); // -6
    printf("%u \n", c); // 2^32 -6

    250:
    0000 0000 0000 0000 0000 0000 1111 1010
    将250赋值给c:(低字节保留，高字节丢弃)
    1111 1010
    以%d打印c，相当于c变 int 属于 短-->长
    低字节直接拷贝，高字节如果短的是无符号，补0，如果有符号，补符号位
    char c 有符号，补符号位1，存储形式如下:
    1111 1111 1111 1111 1111 1111 1111 1010
    想知道存储的有符号数的值，需要求其原码。按照负数原码的方式进行逆向运算
    -1:
    1111 1111 1111 1111 1111 1111 1111 1001
    取反:
    0000 0000 0000 0000 0000 0000 0000 0110  //绝对值原码: 6
    //所以打印的是 -6

    以%u 的方式打印c , c-> unsigned int 
    属于短变长，低字节直接拷贝，char c 有符号，所以全补符号位1
    1111 1111 1111 1111 1111 1111 1111 1010 
    --->printf将其解释为 unsigned int，所有的位都是数值位，所以是 2^32 -6


    --------

    unsigned char c = 250;
    printf("%d \n",c); // 250
    printf("%u \n",c); // 250

    250:
    0000 0000 0000 0000 0000 0000 1111 1010
    c:
    1111 1010
    %d打印: c-> int ,短变长，短的无符号数，所以高位补0:
    0000 0000 0000 0000 0000 0000 1111 1010
    %u打印: c-> unsigned int 短变长，短的无符号数，所以高位补0:
    0000 0000 0000 0000 0000 0000 1111 1010

    打印的结果都是250
    //printf不会改变存储方式，只是对其作出"解释"
```

# 6.整数的类型

```c
//本部分了解即可
GNU有一个标准的头文件， <stdint.h>


    int8_t //有符号的8bits整数类型 char
        -128 ~ 127
    uint8_t //无符号的8bits的整数类型 unsigned char 
        0~255

    int16_t //有符号的16bits整数类型
    uint16_t //无符号的16bits的整数类型 

    int32_t
    uint32_t

    int64_t
    uint64_t
    
    ...


使用示例:
#include <stdio.h>
#include <stdint.h>

int main()
{
    int8_t a;
    a = INT8_MAX;

    return 0;
}

//例如 已经在stdint.h 这个头文件中已经定义好的宏:
#define INT8_MAX 127
#define INT16_MAX 32767

#define 是一个宏，后续在您的代码中 INT8_MAX 等效于是 127
INT8_MAX //宏，有符号8bits的整数的最大值 127
......


```

# 7.常量

```c
    常量: 在程序运行期间，其值不能被修改的数据对象

    符号常量的定义方式: 
    #define PI 3.14 //定义了一个符号常量
    符号常量: 就是使用一个符号来代替一个常量
    PI 就代替了常量3.14
    后续在程序中碰到PI自动替换为3.14 (提高程序可读性)

1. 常量的形式
(1) 整型常量: 在代码文本中，代表整数的常量值 
        八进制整型常量:
        以字符0开头后面接0或者多个 0-7的字符
        如:
            0123
            0777
            0123132
            088  //错误

            int a = 0123;
            printf("a = %d\n",a);
            
        八进制与二进制的关系
            一位八进制数字对应的三位二进制数字
            八进制          二进制
             0             000
             1             001
             2             010
             .....

        十六进制整型常量:
        以字符 0x/0X 开头接1个或者多个十六级禁止字符
        分别用 ABCDEF 代表 10-15
        如:
            0xff
            0x123
            0x89a
            0x23K //错误

        十六进制与二进制关系
            一位十六进制对应 四位二进制数字 
            十六进制            二进制
             0x0                0000
             0x1                0001
             0xff               1111 1111

(2)字符常量
        字符常量是 用单引号(英文的单引号)引起来的一个或者多个字符的序列
        如:
            'a'
            '\n'
                
        在计算机中，保存一个字符，保存的是字符的ascii吗，而不是它的形状
        ASCII:American Standard Code for Information Interchange.
            美国把每个字符分配一个唯一的整数值来标识他们，这个整数值就是我们说的ASCII码。
            由于美国使用字符数不超过256个，所以这个整数值只需要8bit就可以保存

        ASCII ---> char / unsigned char 8 bits

        在虚拟机的终端输入 man ascii 回车，可以查看ASCII码表
        按键盘的 E 往下翻页


        把字符分为两类:
        a. 普通字符: 可以打印的字符
        如:
            'a' ~ 'z'
            'A' ~ 'Z'
            '0' ~ '9'  //注意区分数值 的0-9 和 字符的0-9 不是一个概念
            ....

            char a = 'a';

        b. 特殊字符(转义字符): 不可以打印的字符，没有形状
            '\n' : 换行符
            '\r' : 回车符
            '\t' : 制表符
            ...

            'ooo' : 由\后跟1到3个八进制数字组成
                这些八进制数字用来指定所期望的字符的ASCII码             
                如: 'A' 65 101 41
                    'A'
                    '\101'  //八进制的101
                    '\x41'  //十六进制的41
            '\xhh': 由\x后跟1个或者2个十六进制数字组成，x是固定的
                这些十六进制数字用来指定所期望的字符的ASCII码
                如:
                    char ch = 'A';
                    char ch = '\101';
                    char ch = '\x41';
                    char ch = 65;
                    char ch = 0101;
                    char ch = 0x41;
        
        null字符，ASCII码为 0 的字符，一般用来标识字符串的结束
            '\0' --> 0 
            char ch = '\0';
            char ch = 0;

*注意:
    (1) 字符常量 和 字符串常量 是不一样的
        字符常量 表示的单个字符，用单引号引起来
            如: 'a'
        字符串常量 表示的一串字符，用双引号引来
            如: "a", "hello"

    (2) 'A' ~ 'Z' 是连续的  
        65
        'a' ~ 'z' 是连续的
        97
        '0' ~ '9' 是连续的
        48

(3) 浮点常量(带小数)
    由整数部分、小数点、小数部分，一个e/E ，一个可选的带符号的整型指数和一个可选的表示类型的后缀(f/F/l/L)

        f/F : float
        l/L : long double
        没有后缀: double

        float a = 23.231;
        double b = 0.231;

        整数部分可以省略，小数部分也可以省略，但是不能同时省略。
    
        e/E 表示 10 的幂 (科学计数法)
        3E3 表示 3乘10的三次方
        3E-3 表示 3乘10的负三次方


        例如:
            float f = 2.3E3; //正确
            float f = .3E3; //正确 0.3乘10的三次方
            float f = 5E3; //正确
            float f = E5;  //错误


```

# 练习

```c
    分析如下程序的输出结果，机器32bits                                                                        
    1. 
    char ch = 65;
    printf("%c \n",ch) ;

    提示:
    %d: int
    %u: unsigned int
    %c: char 并且把它的字符的形状输出
    %x: int 十六进制的整数

    2.
    char ch = 253;
    ch  = ch + 7;
    printf("%d\n",ch);
    printf("%u\n",ch);
    printf("%c\n",ch);
    printf("%x\n",ch);

```

# 作业

```c
    分析如下程序的输出结果，假设机器是32bits
    //可以参考上课笔记自行推导一遍

    1. 
        unsigned int a = -5;

        printf("%d \n",a);  //-5
        printf("%u \n",a);  //2^32-5

        绝对值原码:
        0000 0000 0000 0000 0000 0000 0000 0101
        取反:
        1111 1111 1111 1111 1111 1111 1111 1010
        +1:
        1111 1111 1111 1111 1111 1111 1111 1011


    2.
        int a = 255;
        printf("%d \n",a);  //255
        printf("%u \n",a);  //255

    3.
        char c = 253;
        char d; 
        d = c + 192;
        printf("%d \n",d);  //-67
        printf("%u \n",d);  //2^32-67

        253:
        0000 0000 0000 0000 0000 0000 1111 1101
        c: 长变短 高字节丢弃，低字节保留
        1111 1101
        c + 192: c--> 32 bits,短变长，有符号数补符号位，全补1
        1111 1111 1111 1111 1111 1111 1111 1101 (补码)

        192:
        0000 0000 0000 0000 0000 0000 1100 0000 (补码)
        c+192 将上述两个的补码相加得到
        0000 0000 0000 0000 0000 0000 1011 1101 (实际存储的内容)
        赋值给d: 长变短 保留低位   1011 1101 
         
        以%d打印时， 将其当作有符号 int 补符号位成32bits
        1111 1111 1111 1111 1111 1111 1011 1101 
        此时表示是一个负数，逆运算
        -1
        1111 1111 1111 1111 1111 1111 1011 1100
        取反:
        0000 0000 0000 0000 0000 0000 0100 0011 (绝对值原码)
        //-67



    4.
        int a = 9.5;
        printf("%d",a);
    
        (int)9.5  ---> 将9.5浮点类型 强制转换成int型


        //在C中强制转换格式:  (数据类型)变量 

        其他强转示例: 
        (char)a;//将a强制转换成 char
```
